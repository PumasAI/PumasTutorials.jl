---
title : Exercise PK41 - Fitting Multiple intraveneous infusions - NCA vs regression
date: `j Date(now())`
---

```julia; echo = false
using Dates
```

## Objectives

In this exercise we will highlight the **benefits of simultaneously modeling** multiple
 sources of intravenous infusion. When we have multiple sources we can obtain
 better precision of the parameters even with lesser number of samples.

The basic workflow for the estimation process is:

 1. Description of the data
 2. Exploratory analysis of the data
 3. NCA Analysis
 4. Pharmacokinetic modelling
 5. Diagnostic Plots
 6. Validation

Lets load the necessary `libraries` before we get started

```julia
using PumasTutorials
using Random
using CSV
using Pumas
using Plots
using StatsPlots
using Pipe
using StatsBase
using PrettyTables
```

## Description of data

Each group of 20 subjects received an infusion of different doses 310, 520 and
 780 μg/kg body weight as an intravenous infusion over 5 hrs. A total of 60 patients
 are enrolled in the study and PK samples are collected at `0.1,2,5,6,8,10 hrs`.

The following are the units of the dataset:

 * Time (time) = hrs
 * Plasma Concentrations (dv_cp) = μg/L
 * Dose (amt) = μg/kg
 * Group dose (310, 520, 780)

```julia
pk41_data_df = CSV.read("/Users/Parsshava/Desktop/Julia/PumasTutorials.jl/tutorials/PKPDDataAnalysisBook/pk41_fit/pk_41.csv",
  DataFrame, missingstrings = ["", ".", "NA", "BQL"])
```

Basic summary `statistics` of the data

```julia
stats_pk41_data = describe(pk41_data_df, :min, :max, :mean, :std, :nmissing, cols=[:id,:time,:dv])
```

## Exploratory Plots of the given data

* Plot of Plasma Concentration vs Time

```julia
pk_data_plot = dropmissing(pk41_data_df, :dv)
filter!(x -> x.time != 0.0, pk_data_plot)
@df pk_data_plot plot(:time, :dv, group=:id, color=:dose, yaxis=:log, label=false,
                      xlabel="Time (hr)", ylabel="Concentration (ug/L)",
                      guidefontsize = 12, size = (600, 600), alpha=0.5,
                      title = "Plasma Concentrations vs Time")
```

## NCA Analysis

We will now perform an NCA Analysis to get initial estimates of the data for the
 fitting of the given data. We will include a route column to specify that dosing
 is an intravenous infusion `inf`. The *read_nca()* function input requires the route
 to be stated as `inf` for an intravenous infusion, this will help to compute the
 parameters correctly.

```julia; results="hidden"
pk41_data_df[:, :route] .= "inf"
```

We will perform an NCA of the `Plasma Concentrations`. We have grouped it by _dose_,
 this will help us in understanding the difference between the doses and help
 with plotting.

```julia
pk41_data_df[:, :duration] = pk41_data_df.amt ./ pk41_data_df.rate

pk41_nca_plasma = read_nca(pk41_data_df,
                            id       = :id,
                            time     = :time,
                            amt      = :amt,
                            conc     = :dv,
                            route    = :route,
                            duration = :duration,
                            group    = [:dose])
```

A `full NCAReport` is generated, we will then perform summary statistics of the
 required parameters to obtain the **Mean, GeometricMean, and SD**

```julia
pk41_nca_plasma_report = NCAReport(pk41_nca_plasma, sigdig=3)
```

Perform the Summary `Statistics` for the required NCA Parameters.

```julia
## Select the required parameters from the NCA Report
stats_nca_plasma_df = select(pk41_nca_plasma_report, [:id, :vz_obs, :cl_obs, :kel, :half_life,
   :cmax, :mrtinf_obs, :dose])

## Stack the data for easy computation
stats_nca_plasma_stacked = stack(stats_nca_plasma_df, [:vz_obs, :cl_obs, :kel, :half_life,
   :cmax, :mrtinf_obs], [:id, :dose])
stats_nca_plasma_summary = combine(groupby(stats_nca_plasma_stacked,[:dose, :variable]),
                            [col => fun for col in [:value]
                            for fun in [mean, geomean, std]])
```

Plot of **Clearance vs Dose**

```julia
filter!(x -> x.variable == "cl_obs", stats_nca_plasma_summary)
@df stats_nca_plasma_summary plot(:dose, :value_mean, label=false, linewidth=3,
                            xlabel="Dose (ug/kg)", ylabel="Clearance (L/hr/kg)",
                            size = (600, 600), guidefontsize = 12,
                            title = "Clearance vs Time" )
@df stats_nca_plasma_summary scatter!(:dose, :value_mean, label=false, markersize=8)
```

We can see that the **clearance deceases as the dose increases**. Thus we will
 model the data as a non-linear elimination.

From the Clearance and Cmax for the doses we will estimate the values for **Vmax and Km**
 using the formula Cl = Vmax/(Km+C). Thus we get the value for **Vmax = 310 μg/hr/kg** and
 **Km = 150 μg/L**


## Pharmacokinetic Modelling

##### Read the dataset into read_pumas()

```julia
pk41_est_df = filter(x -> (!(x.time == 0  && x.evid == 0.0)), pk41_data_df)

pk41_data = read_pumas(pk41_est_df,
                      id           = :id,
                      time         = :time,
                      observations = [:dv],
                      amt          = :amt,
                      evid         = :evid,
                      cmt          = :cmt,
                      rate         = :rate,
                      covariates   = [:dose])
```

##### One-Compartment Non-linear Elimination

```julia
pk_41        = @model begin
  @param begin
    tvvmax   ∈ RealDomain(lower=0)
    tvkm     ∈ RealDomain(lower=0)
    tvvc     ∈ RealDomain(lower=0)
    Ω        ∈ PDiagDomain(3)
    σ²_prop  ∈ RealDomain(lower=0)
  end

  @random begin
    η        ~ MvNormal(Ω)
  end

  @pre begin
    Vmax     = tvvmax * exp(η[1])
    Km       = tvkm * exp(η[2])
    Vc       = tvvc  * exp(η[3])
  end

  @dynamics begin
    Central' = - (Vmax * (Central/Vc)/(Km + (Central/Vc)))
  end

  @derived begin
    cp       = @. Central/Vc
    dv       ~ @. Normal(cp, sqrt(cp^2*σ²_prop))
  end
end
```

We have obtained the initial parameters using `NCA` and other derivations.

```julia
param_est  = ( tvvmax   = 310,
                tvkm    = 150,
                tvvc    = 1.3,
                Ω       = Diagonal([0.04,0.04,0.04]),
                σ²_prop = 0.02)
```

##### NaivePooled Analysis

A quick estimation of the mean parameters can be done by performing a NaivePooled
 Analysis. This will give us a good judgemnt of the parameters obtained from NCA
 Analysis and provide better inital estimates for the fitting.

```julia
pk_41_fit_nv = @time fit(pk_41, pk41_data, param_est,
                            Pumas.NaivePooled(), ensemblealg=EnsembleThreads(),
                            omegas=(:Ω,))

coeftable(pk_41_fit_nv)
```

We see that the initial estimates we found are not very close to the NaivePooled
 Analysis. But they are still good estimates to let the system find the best
 local minima using `FOCEI`

```julia
pk_41_fit = @time fit(pk_41, pk41_data, param_est,
                        Pumas.FOCEI(), ensemblealg=EnsembleThreads())

coeftable(pk_41_fit)
```

We will obtain the `precision` of the parameters

```julia
pk_41_infer   = coeftable(infer(pk_41_fit))
```

We will `inspect` the diagnostics of the model before we go for the goodness of
 fit plots.

```julia
pk_41_inspect = inspect(pk_41_fit) |> DataFrame
```

## Diagnostic Plots

##### Goodness of Fit Plots

```julia
theme(:wong2)

function gof(pktvp_mr_inspect_run2)
  p1 = plot()
  @df pktvp_mr_inspect_run2 scatter!(
      p1,
      :dv_pred, :dv;
      ylabel = "Observed dv (ug/L)",
      xlabel = "Population Predicted (ug/L)",
      label = "",
      legend=false,
  )
  Plots.abline!(p1,  1, 0; primary = false, color=:red, linewidth=4)

  #
  p2 = plot()
  @df pktvp_mr_inspect_run2 scatter!(
    p2,
    :dv_ipred, :dv;
    ylabel = "Observed Plasma Conc (ug/L)",
    xlabel = "Individual Predicted (ug/L)",
    label = "",
    legend=false,
  )
  Plots.abline!(p2, 1, 0; primary = false, color=:red, linewidth=4)

  p3 = plot()
  @df pktvp_mr_inspect_run2 scatter!(
    p3,
    :time, :dv_wres;
    xlabel = "Time (hr)",
    ylabel = "Conditional Weighted Residuals",
     legend=false
  )
  Plots.abline!(p3, 0, 0; primary = false, color=:red, linewidth=4)

  p4 = plot()
  @df pktvp_mr_inspect_run2 scatter!(
   p4,
   :dv_pred, :dv_wres,
   xlabel = "Population Predicted (ug/L)",
   ylabel = "Conditional Weighted Residuals",
   legend=false
  )
  Plots.abline!(p4, 0, 0; primary = false, color=:red, linewidth=4)

  return plot(p1,p2,p3,p4; size = (1000, 1000))
end

gof(pk_41_inspect)
```

##### Correlation Plots

```julia
@df pk_41_inspect corrplot([:η_1 :η_2 :η_3])
```

##### η-Distribution

```julia
data41_etacov = select(pk_41_inspect,["η_1", "η_2", "η_3"])
data41_etacov = stack(data41_etacov, ["η_1", "η_2", "η_3"])
data41_etacov[!,:variable] .= string.(data41_etacov.variable)
@df data41_etacov groupedviolin(:variable,:value,
                               alpha =0.5, legend=false)
@df data41_etacov groupedboxplot!(:variable,:value,
                               alpha =0.5, label ="")
Plots.abline!(0,0, linewidth=4, color = "black",
              size = (800, 800),
              xlabel = "η's", ylabel = "η_values",
              guidefontsize = 22,
              tickfontsize =14, label ="")
```

## Validation

We will perform a validation of the final model using a `Visual Predictive Check`.

```julia
pk_vpc = vpc(pk_41_fit, 200; dv=:dv,
              stratify_by = [:dose],
              ensemblealg=EnsembleSerial())

plot(pk_vpc,
    size=(1200,1200), xlabel="Time after dose (hr)",
    ylabel = "Concentration (ug/L)" ,
    titlefontsize=20,guidefontsize=20, yaxis=:log,
    markersize=7, markeralpha = 0.5, markercolor =:grey,
    observations = true,
    observed_quantiles = true,
    simquantile_medians = true,
    ci_bands = true,
    legend=:bottomleft, legendfontsize = 12,
    titlefontcolor = :blue,
    linewidth = 5,
    xtickfont = font(20),
    ytickfont = font(20))
```
