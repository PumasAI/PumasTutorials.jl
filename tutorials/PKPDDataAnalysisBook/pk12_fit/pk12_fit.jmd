---
title: Exercise PK12 - Estimation of Intravenous and Oral Dosing to find Bioavailability
date: `j Date(now())`
---

```julia; echo = false
using Dates
```

## Objectives

In this exercise we will learn how to estimate the **bioavailability**. When the relative
 or absolute bioavailability of the drug is to be estimates, the drug must be given
 both orally and intravenous. We need to assume that the clearance is the same on both
 occasions. In order that we eliminate such a risk the oral and iv doses are given
 seperately with a gap of `30 mins to 1 hr`. For this exercise we will dose orally
 followed with intravenous dosing. The basic workflow for the estimation process is:

 1. Description of the data
 2. Exploratory analysis of the data
 3. NCA Analysis
 4. Pharmacokinetic modelling
 5. Diagnostic Plots
 6. Validation

Lets load the necessary `libraries` before we get started

```julia
using Pumas
using PumasTutorials
using Random
using CSV
using Plots
using StatsPlots
using Pipe
using StatsBase
using PrettyTables
```

## Description of the data

A dose of **2.5 mg** of the drug is given orally at `time = 0 mins` followed with an Intravenous
 Infusion for 15 mins, dose of **0.5 mg** 1 hour post the oral dose at `time = 60 mins`. PK samples
 are collected at the following time points 6, 10, 15, 20, 30, 45, 59.9, 63, 66,
 75, 80, 90, 107, 119, 134, 150 mins. A total of 16 samples are collected from each
 patient.

The following are the units of the dataset:

 * Time (time) = mins
 * Plasma Concentration (dv) = μg/L
 * Dose (amt) = mg/kg

```julia
pk12_data_df = CSV.read("/Users/Parsshava/Desktop/Julia/PumasTutorials.jl/tutorials/PKPDDataAnalysisBook/pk12_fit/pk_12.csv",
 DataFrame, missingstrings=["", ".", "NA", "BQL"])
```

Basic summary `statistics` of the data

```julia
stats_pk12_data = describe(pk12_data_df, :min, :max, :mean, :std, :nmissing, cols=[:id,:time,:dv])
```

## Exploratory Plots of the given data

 * Plot of Concentration vs Time

```julia
pk_data_plot = dropmissing(pk12_data_df, :dv)
@df pk_data_plot plot(:time, :dv, group=:id, yaxis=:log, label=false,
                      xlabel="Time (mins)", ylabel="Concentration (ug/L)",
                      title = "Concentrations vs Time")
```

## NCA Analysis

We will now perform an NCA analysis to get the initial estimates for fitting of
 the given data. We will perform an NCA on the oral and IV data seperately. This
 will help us to compute the parameters required for the analysis.

```julia; results="hidden"
#Filter the Oral Data
pk12_data_nca_oral = filter(x -> x.time <= 59.9, pk12_data_df)
pk12_data_nca_oral[:, :route] .= "ev"
#Since the amt is in mg we will convert it to μg
pk12_data_nca_oral[:, :amt] = ifelse.(pk12_data_nca_oral.time .== 0, 2500, missing)

# Filter the Inf Data
pk12_data_nca_inf = filter(x -> x.time >= 60, pk12_data_df)
pk12_data_nca_inf[:, :route] .= "inf"
#Since the amt is in mg we will convert it to μg
pk12_data_nca_inf[:, :amt] = ifelse.(pk12_data_nca_inf.time .== 60.0, 500, missing)
```

##### NCA - Oral Data

Now, map the data variables to the read_nca function that prepares the data for NCA analysis.
 You can even type **?read_nca** in the REPL and get more information on the mapping of the variables.

```julia
pk12_nca_oral = read_nca(pk12_data_nca_oral,
                         id     = :id,
                         time   = :time,
                         amt    = :amt,
                         conc   = :dv,
                         route  = :route)

pk12_oral_nca_report = NCAReport(pk12_nca_oral, sigdig=3)
```

Perform the Summary Statistics for the oral data to get the required NCA Parameters

```julia
## Select the required parameters from the NCA Report
stats_nca_df = select(pk12_oral_nca_report, [:id, :vz_f_obs, :cl_f_obs, :kel, :half_life, :aucinf_obs, :tmax, :tlag])

## Stack the data for easy computation
stats_nca_stacked = stack(stats_nca_df, [:vz_f_obs, :cl_f_obs, :kel, :half_life, :aucinf_obs, :tmax, :tlag], [:id])
stats_nca_summary = combine(groupby(stats_nca_stacked,[:variable]),
                            [col => fun for col in [:value]
                            for fun in [mean, geomean, std]])
```

##### NCA - Infusion Data

```julia
pk12_nca_inf = read_nca(pk12_data_nca_inf,
                          id     = :id,
                          time   = :time,
                          amt    = :amt,
                          conc   = :dv,
                          rate   = :rate,
                          route  = :route)

pk12_inf_nca_report = NCAReport(pk12_nca_inf, sigdig=3)
```
Perform the Summary `Statistics` for the Infusion data to get the required NCA Parameters

```julia
## Select the required parameters from the NCA Report
stats_nca_df = select(pk12_inf_nca_report, [:id, :vz_obs, :cl_obs, :kel, :half_life, :aucinf_obs])

## Stack the data for easy computation
stats_nca_stacked = stack(stats_nca_df, [:vz_obs, :cl_obs, :kel, :half_life, :aucinf_obs], [:id])
stats_nca_summary = combine(groupby(stats_nca_stacked,[:variable]),
                            [col => fun for col in [:value]
                            for fun in [mean, geomean, std]])
```

## Pharmacokinetic Modelling

##### Read the dataset into read_pumas()

First we will try to fit the data to a one-compartment model

```julia
## If there are any 0 values in dv because of lag time we will set them to missing
replace!(pk12_data_df.dv,0.0 => missing)

pk_data = read_pumas(pk12_data_df,
                      id           = :id,
                      time         = :time,
                      observations = [:dv],
                      amt          = :amt,
                      evid         = :evid,
                      cmt          = :cmt)
```

##### One-Compartment Model


```julia
pk_12_1cmt      = @model begin
  @param begin
    tvka        ∈ RealDomain(lower=0)
    tvcl        ∈ RealDomain(lower=0)
    tvvc        ∈ RealDomain(lower=0)
    tvF         ∈ RealDomain(lower=0)
    Ω           ∈ PDiagDomain(4)
    σ²_prop     ∈ RealDomain(lower=0)
  end

  @random begin
    η           ~ MvNormal(Ω)
  end

  @pre begin
    CL          = tvcl * exp(η[1])
    Vc          = tvvc * exp(η[2])
    Ka          = tvka * exp(η[3])
    bioav       = (Depot = tvF * exp(η[4]),)
  end

  @dynamics Depots1Central1
    #Depot'      = -Ka*Depot
    #Central'    =  Ka*Depot - (Cl/Vc)*Central
  #end

  @derived begin
    cp          = @. 1000*(Central/Vc)
    dv          ~ @. Normal(cp, sqrt(cp^2*σ²_prop))
  end
end
```

We have obtained the initial parameters for One-Compartment Model from NCA analysis

```julia
param_est_1cmt = (tvka    = 0.12,
                  tvcl    = 0.3,
                  tvvc    = 0.27,
                  tvF     = 0.04,
                  Ω       = Diagonal([0.04,0.04,0.04,0.04]),
                  σ²_prop = 0.06)
```

##### Naive Pooled

A quick estimation of the mean parameters can be done by performing a NaivePooled
 Analysis. This will give us a good judgemnt of the parameters obtained from NCA
 Analysis and provide better inital estimates for the fitting.

```julia
pk_12_fit_1cmt = @time fit(pk_12_1cmt, pk_data, param_est_1cmt,
                           Pumas.NaivePooled(), ensemblealg=EnsembleThreads(),
                           omegas=(:Ω,))

coeftable(pk_12_fit_1cmt)
```

##### FOCEI

We will now use the mean estimates from the NaivePooled Analysis for fitting the
 data and obatining the Between Subject Variability (BSV) on the parameters.

```julia
pk_12_fit_1cmt_focei = @time fit(pk_12_1cmt, pk_data, param_est_1cmt,
                           Pumas.FOCEI(), ensemblealg=EnsembleThreads())

coeftable(pk_12_fit_1cmt_focei)
```

We will generate a few goodness of fit plots to compare which model is performing
 better. We will first inspect the diagnostics of our models.

```julia
pk_12_inspect_1cmt_focei = inspect(pk_12_fit_1cmt_focei) |> DataFrame
```

## Diagnostic Plots

##### Goodness of Fit Plots

 * One-Compartment Model

```julia
theme(:wong2)

function gof(pktvp_mr_inspect_run2)
  p1 = plot()
  @df pktvp_mr_inspect_run2 scatter!(
      p1,
      :dv_pred, :dv;
      ylabel = "Observed dv (ug/L)",
      xlabel = "Population Predicted (ug/L)",
      label = "",
      legend=false,
  )
  Plots.abline!(p1,  1, 0; primary = false, color=:red, linewidth=4)

  #
  p2 = plot()
  @df pktvp_mr_inspect_run2 scatter!(
    p2,
    :dv_ipred, :dv;
    ylabel = "Observed dv (ug/L)",
    xlabel = "Individual Predicted (ug/L)",
    label = "",
    legend=false,
  )
  Plots.abline!(p2, 1, 0; primary = false, color=:red, linewidth=4)

  p3 = plot()
  @df pktvp_mr_inspect_run2 scatter!(
    p3,
    :time, :dv_wres;
    xlabel = "Time (mins)",
    ylabel = "Conditional Weighted Residuals",
     legend=false
  )
  Plots.abline!(p3, 0, 0; primary = false, color=:red, linewidth=4)

  p4 = plot()
  @df pktvp_mr_inspect_run2 scatter!(
   p4,
   :dv_pred, :dv_wres,
   xlabel = "Population Predicted (ug/L)",
   ylabel = "Conditional Weighted Residuals",
   legend=false
  )
  Plots.abline!(p4, 0, 0; primary = false, color=:red, linewidth=4)

  return plot(p1,p2,p3,p4; size = (1000, 1000))
end

gof(pk_12_inspect_1cmt_focei)
```

##### Two-Compartment Model

We will now fit a two-compartment model

```julia
pk_12_2cmt      = @model begin
  @param   begin
    tvka        ∈ RealDomain(lower=0)
    tvcl        ∈ RealDomain(lower=0)
    tvq         ∈ RealDomain(lower=0)
    tvvc        ∈ RealDomain(lower=0)
    tvvp        ∈ RealDomain(lower=0)
    tvlag       ∈ RealDomain(lower=0)
    tvF         ∈ RealDomain(lower=0)
    Ω           ∈ PDiagDomain(6)
    σ²_prop     ∈ RealDomain(lower=0)
  end

  @random begin
    η           ~ MvNormal(Ω)
  end

  @pre begin
    CL          = tvcl * exp(η[1])
    Q           = tvq
    Vc          = tvvc * exp(η[2])
    Vp          = tvvp * exp(η[3])
    Ka          = tvka * exp(η[4])
    lags        = (Depot = tvlag * exp(η[5]),)
    bioav       = (Depot = tvF * exp(η[6]),)
  end

  @dynamics Depots1Central1Periph1
    #Depot'      = -Ka*Depot
    #Central'    =  Ka*Depot - (Cl/Vc)*Central - (Q/Vc)*Central + (Q/Vp)*Peripheral
    #Peripheral' =  (Q/Vc)*Central - (Q/Vp)*Peripheral
  #end

  @derived begin
    cp          = @. 1000*(Central/Vc)
    dv          ~ @. Normal(cp, sqrt(cp^2*σ²_prop))
  end
end
```

 * Initial Parameters for Two Compartment

```julia
param_est_2cmt = (tvka    = 0.11,
                  tvcl    = 0.012,
                  tvq     = 0.012,
                  tvvc    = 0.14,
                  tvvp    = 0.14,
                  tvlag   = 3.2,
                  tvF     = 0.033,
                  Ω       = Diagonal([0.017,0.02,0.028,0.04,0.04,0.04]),
                  σ²_prop = 0.14)
```

We will try to fit a two-compartment model `without lag` to the given data.

```julia
pk_12_fit_2cmt_nolag = @time fit(pk_12_2cmt, pk_data, param_est_2cmt,
                      Pumas.FOCEI(), ensemblealg=EnsembleThreads(),
                      constantcoef=(tvlag=0.00001,))

coeftable(pk_12_fit_2cmt_nolag)
```

We will try to fit a two-compartment model `with lag` to the given data.

```julia
pk_12_fit_2cmt_lag = @time fit(pk_12_2cmt, pk_data, param_est_2cmt,
                      Pumas.FOCEI(), ensemblealg=EnsembleThreads())

coeftable(pk_12_fit_2cmt_lag)
```

We will now obtain the parameter `precision` of the model.

```julia
pk_12_infer_2cmt_lag = coeftable(infer(pk_12_fit_2cmt_lag))
```

Comparison between `One-compartment` model and `Two-compartment` model *without/with lag time*

```julia
DataFrame([(metric=string(f), fit_1cmt=f(pk_12_fit_1cmt_focei), fit_2cmt_nolag=f(pk_12_fit_2cmt_nolag),
 fit_2cmt_lag=f(pk_12_fit_2cmt_lag)) for f in (aic, bic)])
```

The Two-compartment model with lag is a better fit to the data. We will now compare
 the diagnostic plots.

```julia
pk_12_infer_2cmt_nolag = inspect(pk_12_fit_2cmt_nolag) |> DataFrame
pk_12_infer_2cmt_lag   = inspect(pk_12_fit_2cmt_lag) |> DataFrame
```

 * Without-lag Time

```julia
gof(pk_12_infer_2cmt_nolag)
```

 * With-lag Time

```julia
gof(pk_12_infer_2cmt_lag)
```

Clearly the model with a `lag compartment` is a better fit to the given data.

```julia
data12_etacov = select(pk_12_infer_2cmt_lag,["η_1", "η_2", "η_3", "η_4", "η_5", "η_6"])
data12_etacov = stack(data12_etacov, ["η_1", "η_2", "η_3", "η_4", "η_5", "η_6"])
data12_etacov[!,:variable] .= string.(data12_etacov.variable)
@df data12_etacov groupedviolin(:variable,:value,
                               alpha =0.5, legend=false)
@df data12_etacov groupedboxplot!(:variable,:value,
                               alpha =0.5, label ="")
Plots.abline!(0,0, linewidth=4, color = "black",
              size = (1000, 1000),
              xlabel = "η's", ylabel = "η_values",
              guidefontsize = 22,
              tickfontsize =14, label ="")
```

## Validation

We will perform a validation of the final model using VPC check.

```julia
pk_vpc = vpc(pk_12_fit_2cmt_lag, 200; dv=:dv,
             ensemblealg=EnsembleSerial())

plot(pk_vpc,
    size=(800,800), xlabel="Time after dose (mins)",
    ylabel = "Concentration (ug/L)" ,
    titlefontsize=20,guidefontsize=20,
    markersize=7, markeralpha = 0.5, markercolor =:grey,
    observations = true,
    observed_quantiles = true,
    simquantile_medians = true,
    ci_bands = true,
    legend=true, legendfontsize = 12,
    titlefontcolor = :blue,
    linewidth =5,
    xtickfont = font(20),
    ytickfont = font(20))
```
