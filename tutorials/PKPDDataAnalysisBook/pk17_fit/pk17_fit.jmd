---
title: Exercise PK17 - Fitting Nonlinear kinetics - Capacity 1
date: `j Date(now())`
---

```julia; echo = false
using Dates
```

## Objectives

In this exercise we will try to fit a one-comparmtent model with first order elimination
 and a michaelis-menten elimination. It is very important to have adequate data to
 help us distinguish and make comparisons between the models.

The basic workflow of the estimation process is

 1. Description of the data
 2. Exploratory analysis of the data
 3. NCA Analysis
 4. Pharmacokinetic modelling
 5. Diagnostic Plots
 6. Validation

Lets load the necessary `libraries` before we get started

```julia
using PumasTutorials
using Random
using CSV
using Pumas
using Plots
using StatsPlots
using Pipe
using StatsBase
```

## Description of the data

A new drug is administered as a rapid infusion at a dose of `1800 μg` over *0.5 mins*
 followed by a slow infusion at a dose of `5484.8 μg` over 39.63 mins. PK samples are
 collected at the following time points - `0.1, 5.38, 10.33, 15.3, 20.35, 23.13, 28.15,
 33.18, 38.23, 40.62, 45.25, 50.08, 60.42, 80.35 mins`. A total of 14 samples are collected
 from each patient.

The following are the units of the dataset:

 * Time (time) = mins
 * Plasma Concentration (dv) = μg/mL
 * Dose (amt) = μg

```julia
pk17_data_df = CSV.read("/Users/Parsshava/Desktop/Julia/PumasTutorials.jl/tutorials/PKPDDataAnalysisBook/pk17_fit/pk_17.csv",
  DataFrame, missingstrings=["", ".", "NA", "BQL"])
```

Basic summary `statistics` of the data

```julia
stats_pk17_data = describe(pk17_data_df, :min, :max, :mean, :std, :nmissing, cols=[:id,:time,:dv])
```

## Exploratory Plots of the given data

 * Plot of *Concentration vs Time*

```julia
pk_data_plot_plasma = dropmissing(pk17_data_df, :dv)
@df pk_data_plot_plasma plot(:time, :dv, group=:id, label=false,
                             xlabel="Time (mins)", ylabel="Concentration (ug/mL)",
                             size = (600, 600), guidefontsize = 12,
                             title = "Plasma Concentrations vs Time")
```

## NCA Analysis

We will now perform an NCA analysis of the slow infusion dose to get the initial
 estimates for the fitting of the given data. From the terminal slope value we can
 obtain the parameters like `Clearance` and `Volume of Distribution`. The route
 column will need to be included to indicate the dosing is an *infusion* `inf`.
 The *read_nca* function input requires the route to be stated as inf for infusion,
 this will help to compute the parameters correctly.

We will filiter the data to include only the concentrations after the second dose.
 Since it is an infusion we will calculate the duration. We do this by dividing the
 `amount` by `rate`.

```julia; results="hidden"
pk17_nca_df = filter(x -> x.time >=0.5, pk17_data_df)
pk17_nca_df[:, :duration] .= pk17_nca_df.amt ./ pk17_nca_df.rate
pk17_nca_df[:, :route] .= "inf"
```

Now, map the data variables to the readnca function that prepares the data for NCA
 analysis. You can even type **?readnca** in the REPL and get more information on
 the mapping of the data.

```julia
pk17_nca = read_nca(pk17_nca_df,
                    id       = :id,
                    time     = :time,
                    amt      = :amt,
                    conc     = :dv,
                    duration = :duration,
                    route    = :route)
```

A full NCAReport is generated, we will then perform summary statistics of the
 required parameters to obtain the **Mean, GeometricMean, and SD**

```julia
pk17_nca_report = NCAReport(pk17_nca, sigdig=3)
```

Perform the Summary `Statistics` for the required NCA Parameters

```julia
## Select the required parameters from the NCA Report
stats_nca_df = select(pk17_nca_report, [:id, :vz_obs, :cl_obs, :kel, :half_life, :vss_obs])

## Stack the data for easy computation
stats_nca_stacked = stack(stats_nca_df, [:vz_obs, :cl_obs, :kel, :half_life, :vss_obs], [:id])
stats_nca_summary = combine(groupby(stats_nca_stacked,[:variable]),
                            [col => fun for col in [:value]
                            for fun in [mean, geomean, std]])
```

We have obtained the Clearance and Volume of Distribution from the NCA Analysis.
 We will use these estimates for fitting of the linear model.

## Pharmacokinetic Modelling

##### Read the dataset into read_pumas()

```julia
pk_data      = read_pumas(pk17_data_df,
                          id           = :id,
                          time         = :time,
                          observations = [:dv],
                          amt          = :amt,
                          evid         = :evid,
                          cmt          = :cmt)
```

##### One-Compartment Model with Linear Elimination

```julia
pk_17_lm    = @model begin
 @param begin
   tvcl     ∈ RealDomain(lower=0)
   tvvc     ∈ RealDomain(lower=0)
   Ω        ∈ PDiagDomain(2)
   σ²_prop  ∈ RealDomain(lower=0)
 end

 @random begin
   η        ~ MvNormal(Ω)
 end

 @pre begin
   CL       = tvcl  * exp(η[1])
   Vc       = tvvc  * exp(η[2])
 end

 @dynamics Central1
   #Central' = - (Cl/Vc)*Central
 #end

 @derived begin
   cp       = @. Central/Vc
   dv       ~ @. Normal(cp,sqrt(cp^2*σ²_prop))
 end
end
```

These estimates are obtained from the NCA Anlaysis

```julia
param_est_lm = (tvcl    = 34,
                tvvc    = 798,
                Ω       = Diagonal([0.04, 0.04]),
                σ²_prop = 0.02)
```

## NaivePooled Analysis

A quick estimation of the mean parameters can be done by performing a NaivePooled
 Analysis. This will give us a good judgemnt of the parameters obtained from NCA
 Analysis and provide better inital estimates for the fitting

```julia
pk_17_fit_lm_nv = @time fit(pk_17_lm, pk_data, param_est_lm,
                         Pumas.NaivePooled(), ensemblealg = EnsembleThreads(),
                         omegas=(:Ω,))

coeftable(pk_17_fit_lm_nv)
```

The estimate for the `Volume of Distribution` seems off from the NCA Analysis. Hence
 we will use the estimates we have obatined from the `NaivePooled` Analysis for the
 fitting using `FOCEI`.

```julia
param_est_lm_nv = (tvcl    = 39,
                   tvvc    = 1430,
                   Ω       = Diagonal([0.04, 0.04]),
                   σ²_prop = 0.02)

pk_17_fit_lm = @time fit(pk_17_lm, pk_data, param_est_lm_nv,
                         Pumas.FOCEI(), ensemblealg = EnsembleThreads())

coeftable(pk_17_fit_lm)
```

We will now obtain the parameter `precision` of the model.

```julia
pk_17_infer_lm = coeftable(infer(pk_17_fit_lm))
```

We will generate a few goodness of fit plots to check the trends in the model.
 We will first inspect the diagnostics of our models.

```julia
pk_17_inspect_lm = inspect(pk_17_fit_lm) |> DataFrame
```

## Diagnostic Plots

##### Goodness of Fit Plots

```julia
theme(:wong2)

function gof(pktvp_mr_inspect_run2)
 p1 = plot()
 @df pktvp_mr_inspect_run2 scatter!(
     p1,
     :dv_pred, :dv;
     ylabel = "Observed dv (ug/mL)",
     xlabel = "Population Predicted (ug/mL)",
     label = "",
     legend=false,
 )
 Plots.abline!(p1,  1, 0; primary = false, color=:red, linewidth=4)

 #
 p2 = plot()
 @df pktvp_mr_inspect_run2 scatter!(
   p2,
   :dv_ipred, :dv;
   ylabel = "Observed dv (ug/mL)",
   xlabel = "Individual Predicted (ug/mL)",
   label = "",
   legend=false,
 )
 Plots.abline!(p2, 1, 0; primary = false, color=:red, linewidth=4)

 p3 = plot()
 @df pktvp_mr_inspect_run2 scatter!(
   p3,
   :time, :dv_wres;
   xlabel = "Time (mins)",
   ylabel = "Conditional Weighted Residuals",
    legend=false
 )
 Plots.abline!(p3, 0, 0; primary = false, color=:red, linewidth=4)

 p4 = plot()
 @df pktvp_mr_inspect_run2 scatter!(
  p4,
  :dv_pred, :dv_wres,
  xlabel = "Population Predicted (ug/mL)",
  ylabel = "Conditional Weighted Residuals",
  legend=false
 )
 Plots.abline!(p4, 0, 0; primary = false, color=:red, linewidth=4)

 return plot(p1,p2,p3,p4; size = (1000, 1000))
end

gof(pk_17_inspect_lm)
```

We can see that are a few trends in the residual plots at the higher time points.
 Now, we will try to fit a **Micahelis Menten Model** to the given data.

##### Micahelis Menten Model

```julia
pk_17_mm     = @model begin
  @param begin
    tvvmax   ∈ RealDomain(lower=0)
    tvkm     ∈ RealDomain(lower=0)
    tvvc     ∈ RealDomain(lower=0)
    Ω        ∈ PDiagDomain(2)
    σ²_prop  ∈ RealDomain(lower=0)
  end

  @random begin
    η        ~ MvNormal(Ω)
  end

  @pre begin
    Vmax     = tvvmax * exp(η[1])
    Km       = tvkm
    Vc       = tvvc   * exp(η[2])
  end

  @dynamics begin
    Central' = - (Vmax/(Km+(Central/Vc))) * (Central/Vc)
  end

  @derived begin
    cp       = @. Central/Vc
    dv       ~ @. Normal(cp,sqrt(cp^2*σ²_prop))
  end
end
```

At very low concentrations of about *1 μg/mL*, we assume the **Km = 1 μg/mL** .
 Using the fomula Cl = Vmax / (Km+C), we calculate Vmax to be approximately
 **84 μg/min**. We will use these as initial estimates for the analysis.

```julia
param_est_mm = (tvvmax  = 84,
                tvkm    = 1,
                tvvc    = 1355,
                Ω       = Diagonal([0.04, 0.04]),
                σ²_prop = 0.02)
```

We will try to the fit the data using `FOCEI`

```julia
pk_17_fit_mm = @time fit(pk_17_mm, pk_data, param_est_mm,
                          Pumas.FOCEI(), ensemblealg = EnsembleThreads())

coeftable(pk_17_fit_mm)
```

We will now obtain the `parameter precision` of the model.

```julia
pk_17_infer_mm = coeftable(infer(pk_17_fit_mm))
```

We will first `inspect` the diagnostics of our models.

```julia
pk_17_inspect_mm = inspect(pk_17_fit_mm) |> DataFrame
```

 * Michaelis-Menten Model

```julia
gof(pk_17_inspect_mm)
```

We will perform a likelihood ratio test to compare the models. From the P-value
 it is clear the michaelis-menten model is a better fit.

```julia
lrtest(pk_17_fit_lm, pk_17_fit_mm)
```

We will compare the other metrics and statistics, such as aic and bic. Clearly
 the Michaelis-menten model is a better fit.

```julia
DataFrame([(metric=string(f), fit_mm=f(pk_17_fit_mm), fit_lm=f(pk_17_fit_lm)) for f in (aic, bic)])
```

## η-Distribution

```julia
data17_etacov = select(pk_17_inspect_mm, ["η_1", "η_2"])
data17_etacov = stack(data17_etacov, ["η_1", "η_2"])
data17_etacov[!,:variable] .= string.(data17_etacov.variable)
@df data17_etacov groupedviolin(:variable,:value, alpha =0.5, label=false)
@df data17_etacov groupedboxplot!(:variable,:value,alpha =0.5, label =false)
Plots.abline!(0,0, linewidth=4, color = "black",
              size = (600, 600),
              xlabel = "η's", ylabel = "η_values", legendtitle = "",
              guidefontsize = 22,
              tickfontsize =14, label =false)
```

## Validation

We will perform a validation of the final model using Visual Predictive Check.

```julia
pk_vpc = vpc(pk_17_fit_mm, 200; dv=:dv,
             ensemblealg=EnsembleThreads())

plot(pk_vpc,
      size=(800,800), xlabel="Time after dose (mins)",
      ylabel = "Concentration (ug/mL)" ,
      title ="Visual Predictive Check",
      titlefontsize=20, guidefontsize=20,
      markersize=5, markeralpha = 0.4, markercolor =:grey,
      observations = true,
      observed_quantiles = true,
      simquantile_medians = true,
      ci_bands = true,
      legend=true, legendfontsize = 10,
      titlefontcolor = :blue,
      linewidth =5,
      xtickfont = font(25),
      ytickfont = font(25))
```
